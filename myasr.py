# -*- coding: utf-8 -*-
"""myASR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hMsDFaENzDc2ZsVXWRE8WCNR8V45Pt5R

**ΠΑΝΕΠΙΣΤΗΜΙΟ ΠΕΙΡΑΙΩΣ**
**ΤΜΗΜΑ ΠΛΗΡΟΦΟΡΙΚΗΣ**

Απαλλακτική εργασία για το μάθημα 'ΕΠΕΞΕΡΓΑΣΙΑ ΣΗΜΑΤΩΝ ΦΩΝΗΣ ΚΑΙ ΗΧΟΥ'

---

*Η εργασία υλοποιήθηκε απο τον φοιτητή:*
***Βεργιάννη Νικόλαο - Π16170***

*Υλοποιήθηκε σε google colab καθώς είναι ένα δωρεάν περιβάλλον Jupyter που λειτουργεί στο cloud. Το colab υποστηρίζει πολλές βιβλιοθήκες μηχανικής μάθησης και μας πάρεχει δωρεαν GPU runtime.*

---

##ΛΙΓΑ ΠΡΑΓΜΑΤΑ ΓΙΑ ΤΑ ΕΠΕΞΕΡΓΑΣΙΑ ΣΗΜΑΤΟΣ


Όταν ένα αντικείμενο δονείται, τα μόρια αέρα ταλαντεύονται από και προς τη θέση ανάπαυσης και μεταδίδουν την ενέργειά του σε γειτονικά μόρια. Αυτό έχει ως αποτέλεσμα τη μετάδοση ενέργειας από ένα μόριο σε άλλο το οποίο με τη σειρά του παράγει ένα ηχητικό κύμα

**ΠΑΡΑΜΕΤΡΟΙ ΕΝΟΣ ΣΗΜΑΤΟΣ ΗΧΟΥ**

![Waves-and-Communication-1 (1).png](data:image/png;base64,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)

*   **Πλάτος:** πλάτος αναφέρεται στη μέγιστη μετατόπιση των μορίων αέρα από τη θέση ηρεμίας
*   **Κορυφή και κοιλότητα**:Η κορυφή είναι το υψηλότερο σημείο του κύματος ενώ η κοιλότητα είναι το χαμηλότερο σημείο
*   **Μήκος κύματος:** Η απόσταση μεταξύ 2 διαδοχικών κορυφών ή γούρνων είναι γνωστή ως μήκος κύματος
*   **Συχνότητα :** Η συχνότητα αναφέρεται στο πόσο γρήγορα αλλάζει ένα σήμα για μια χρονική περίοδο
*  **Κύκλος :** Κάθε ηχητικό σήμα διασχίζει τη μορφή κύκλων. Μια ολοκληρωμένη κίνηση προς τα πάνω και προς τα κάτω του σήματος σχηματίζει έναν κύκλο

**Μετατροπή**

Η μετατροπή πραγματοποιείται μέσω της δειγματοληψίας (sampling), η οποία συνήθως πραγματοποιείται σε δύο στάδια, στο στάδιο της διακριτοποίησης (discretization) και της κβάντισης σήματος (quantization). Η διακριτοποίηση σημαίνει ότι το σήμα χωρίζεται σε ίσα χρονικά διαστήματα και κάθε διάστημα αντιπροσωπεύεται από μία μόνο μέτρηση πλάτους (amplitude). Η κβάντιση σήματος  σημαίνει ότι η κάθε μέτρηση πλάτους προσεγγίζεται με μία τιμή από ένα πεπερασμένο σύνολο. 

Η συχνότητα δειγματοληψίας η ρυθμός δειγματοληψίας μετριέται σε Hz και εκφράζει το πλήθος δειγμάτων που λαμβάνονται σε διάρκεια ενός δευτερολέπτου.

Εάν fs = 8.000Hz σημαίνει οτι ο δειγματολήπτης λαμβάνει 8.000 δείγματα ανα δευτερόλπετο σήματος. Η χρονική απόσταση υπολογίζεται απο τον τύπο 1/Τ, όπου Τ είναι η περίοδος δειγματοληψίας. 
Για fs = 8.000Hz η περίοδος θα είναι Τ = 1/8000 = 0.0008 δευτερόλεπτα.

---

**Θεώρημα Nyquist-Shannon**

Σύμφωνα με το θεώρημα δειγματοληψίας Nyquist–Shannon, το  αποτελεί μία γέφυρα μεταξύ των συνεχών και των διακριτών σημάτων, ένα αναλογικό σήμα μπορεί να αναπαραχθεί από το αντίστοιχο διακριτό όταν έχει χρησιμοποιηθεί συχνότητα δειγματοληψίας η οποία είναι τουλάχιστον διπλάσια από την μέγιστη συχνότητα του αρχικού σήματος. 

Για παράδειγμα, αν οι συχνότητες ενός συνεχούς σήματος εκτείνονται μέχρι τα 8000Hz, τότε πρέπει να χρησιμοποιηθεί συχνότητα δειγματοληψίας τουλάχιστον ίση με 20KHz. Συνηθισμένες συχνότητες δειγματοληψίας για την περίπτωση των ηχητικών σημάτων είναι 44.1KHz για μουσική και 32, 16 ή και 8KHz για ομιλία. 

Επιπλέον, αν και μεγάλες συχνότητες δειγματοληψίας βελτιώνουν την ποιότητα του ψηφιακού σήματος, μπορεί να οδηγήσουν σε μεγάλες υπολογιστικές πολυπλοκότητες στους αλγορίθμους ανάλυσης, καθώς αυξάνουν το πλήθος δειγμάτων ανά δευτερόλεπτο προς επεξεργασία. 


---
"""

from google.colab import drive
drive.mount("/content/drive")

"""Τα αρχεία ήχου είναι ήδη κομμένα ως προς την παυση στην αρχή και το τέλος 
αλλιώς θα χρησιμοποιούσαμε την συνάρτηση trim_silence().
"""

!cp '/content/drive/My Drive/myASR/recordingsdataset/split_to_words.py' .

"""###IMPORT NECESSARY LIBRARIES"""

#system libraries
import os
from os.path import isdir, join
import pathlib
from pathlib import Path
#for data processing

import numpy as np #linear algebra
import pandas as pd 
import scipy
from scipy import signal
from scipy.fftpack import fft
from scipy.io import wavfile

from tensorflow.python.platform import gfile

import _pickle as pickle
import librosa
import librosa.display
import matplotlib.pyplot as plt
import IPython.display as ipd

import warnings
warnings.filterwarnings("ignore")
from sklearn.preprocessing import LabelEncoder, StandardScaler, OneHotEncoder
from sklearn.model_selection import train_test_split


import tensorflow as tf

#keras libraries
from keras.utils import np_utils, to_categorical
from keras.layers import Dense, Dropout, Flatten, Conv1D, Input, MaxPooling1D, SimpleRNN
from keras.callbacks import EarlyStopping, ModelCheckpoint, History
from keras.models import load_model, Sequential
from keras.models import Model
from keras import backend as K
import random
global str

import split_to_words
!pip install pydub


import time

print(tf.__version__)

"""**PATHS**"""

dir_path = '/content/drive/My Drive/myASR'
train_path = '/content/drive/My Drive/myASR/recordingsdataset/recordings'
my_recordings_path = '/content/drive/My Drive/myASR/recordingsdataset/my_recordings'
path = os.path.join(train_path, '*','*.wav')

"""### PLOTTING THE FEATURES OF A WAV FILE

Αλλαγή του index για να κατασκευάσουμε τα διαγραμμάτα για διαφορετικό αρχείο ήχου
"""

index = 0
wave_path = gfile.Glob(path)[index]
sample_rate, samples = wavfile.read(wave_path)
ipd.Audio(samples,rate=sample_rate)

#func to calculate spectrogram of raw wave file
def log_specgram(audio, sample_rate, window_size=20,
                 step_size=10, eps=1e-10):
    nperseg = int(round(window_size * sample_rate / 1e3))
    noverlap = int(round(step_size * sample_rate / 1e3))
    freqs, times, spec = signal.spectrogram(audio,
                                    fs=sample_rate,
                                    window='hann',
                                    nperseg=nperseg,
                                    noverlap=noverlap,
                                    detrend=False)
    return freqs, times, np.log(spec.T.astype(np.float32) + eps)

"""**MFCC feature**

Η βασική ιδέα για τα χαρακτηριστικά MFCC είναι οτι σε κάθε παράθυρο χρόνου, αποδίδει ένα διάνυσμα χαρακτηριστικών που χαρακτηρίζει τον ήχο μέσα στο παράθυρο. Η διάσταση τους είναι πολύ χαμηλότερη απο αυτή του φασματογράφου για αυτο θα την χρησιμοποιήσουμε για το ακουστικό μοντέλο μας ώστε να αποφύγουμε overfitting στο dataset εκπαίδευσης.

---
"""

#RAW WAVE
wave, sr = librosa.load(wave_path, mono=True)
plt.figure(figsize=(16,6))
librosa.display.waveplot(wave, sr=sr)
plt.title("Raw wave of " + wave_path)



## MFccs 
mfccs = librosa.feature.mfcc(y=wave, sr=sr, n_mfcc=13)
plt.figure(figsize=(16,6))
librosa.display.specshow(mfccs,x_axis='time')
plt.title("MFCC of  " + wave_path)
plt.ylabel("Freqs(KHz)")
plt.xlabel("Time(seconds)")
plt.colorbar()

## SPECTROGRAM 
sample_rate, samples = wavfile.read(wave_path)
freqs, times, spectrogram = log_specgram(samples,sample_rate)
plt.figure(figsize=(16,6))
plt.title("Spectrogram of " + wave_path)
plt.ylabel("Freqs(KHz)")
plt.xlabel("Time(seconds)")
plt.imshow(spectrogram.T, aspect="auto",origin="lower",
            extent=[times.min(),times.max(), freqs.min(), freqs.max()])
plt.colorbar()
plt.yticks(freqs[::16])
plt.xticks(times[::16])
plt.show()

"""**PLOT FFT** 


Μετατροπή σήματος σε μεμονωμένα φασματικά στοιχεία που μας παρέχουν πληροφορίες συχνότητας για το σήμα
"""

frs, signal = wavfile.read(wave_path)
print ("Frequency sampling", frs)
l_audio = len(signal.shape)
print ("Channels", l_audio)
if l_audio == 2:
    signal = signal.sum(axis=1) / 2
N = signal.shape[0]
print ("Complete Samplings N", N)
secs = N / float(frs)
print ("secs", secs)
Ts = 1.0/frs # sampling interval in time
print ("Timestep between samples Ts", Ts)
t = scipy.arange(0, secs, Ts) # time vector as scipy arange field / numpy.ndarray
FFT = abs(scipy.fft(signal))
FFT_side = FFT[range(N//2)] # one side FFT range
freqs = scipy.fftpack.fftfreq(signal.size, t[1]-t[0])
fft_freqs = np.array(freqs)
freqs_side = freqs[range(N//2)] # one side frequency range
fft_freqs_side = np.array(freqs_side)
plt.figure(figsize=(16,8))
plt.plot(freqs, FFT) # plotting the complete fft spectrum
plt.title("Fft spectrum  " + wave_path)
plt.xlabel('Frequency (Hz)')
plt.ylabel('Count dbl-sided')
plt.show()

"""### AUDIO PROCESSING

**Fourier Transform**

Ο μετασχηματισμός Fourier χρησιμοποιείται για την ανάλυση προβλημάτων που αφορούν σήματα συνεχούς χρόνου ή μίγματα σημάτων συνεχούς και διακριτού χρόνου.
Πολύ λίγες πληροφορίες χάνονται απο το σήμα κατα την διάρκεια του μετασχηματισμού.
Ο μετασχηματισμός Fourier διατηρεί πληροφορίες σχετικά με το πλάτος, τις αρμονικές και τη φάση και χρησιμοποιεί όλα τα μέρη της κυματομορφής για να μεταφράσει το σήμα στον τομέα συχνοτήτων.
"""

def FFT(fs , y , label):
  N = len(y)
  T = 1.0 / fs

  y_freq = fft(y)
  #1st quarter of frequency domain data
  x_freq = np.linspace(0.0, 1.0/(2.0*T), N//2) * 0.5
  #magnitutude frequency
  y_freq = 2.0 * np.abs(y_freq[:int(N/2)])
 
  # plt.plot(x_freq,y_freq,label=str(label) + ' - file :' + label +"N" + str(N)) # plot the fourier transform
  # plt.show()

  return x_freq,y_freq,N

"""**BANDPASS filter**

Εφαρμόστηκε ένα φίλτρο στα αρχεία εισόδου προκειμένου να μειωθούν τα επίπεδα θορύβου και ταυτόχρονα να διατηρηθούν οι πληροφορίες σήματος που μας ενδιαφέρουν να αναλύσουμε.
Με το φίλτρο διατηρούμε τα δεδομένα σήματος που ανήκουν στην τυπική ζώνη συχνοτήτων που σχετίζεται με το μέσο άτομο.
Η φωνή ενός μέσου ενήλικα άνδρα κυμαίνεται από 85 ~ 180 Hz, ενώ η γυναίκα από 165 ~ 255 Hz.

Το φίλτρο που υλοποιήθηκε είναι bandpass με σημεία αποκοπής τα 85~255 Hz και είναι τύπου IIR butterworth.
"""

from scipy import signal
def bandpassFilter(data, fs, lowcut=85, highcut=250, order=4):
  nyq = 0.5 * fs
  low = lowcut/ nyq
  high = highcut / nyq
  b, a = signal.butter(order, [low, high], btype='bandpass')
  y = signal.lfilter(b, a, data)

  return y

"""**TRIMMING SILENCE**

Αφαιρεί την σιωπή στην αρχή και στο τέλος των δεδομένων ήχου που πέρασε και ταιρίαζει τον θόρυβο βάση των n τελευταίων δειγμάτων και βρίσκει που είναι το μέσο φιλτραρισμένο μέγεθος μεγαλύτερο απο τον θόρυβο

*Τα δεδομένα του dataset είναι ήδη κομμένα ως προς τον θόρυβο οπότε δεν θα χρησιμοποιήσουμε την συνάρτηση*

Θα την χρησιμοποίησουμε όταν θέλουμε να κατατμήσουσε την πρόταση ψηφίων σε λέξεις που εισάγουμε για πρόβλεψη. *βλ. τέλος της σελίδας*
"""

def trim_silence(audio, noise_threshold=150):
    start = None
    end = None

    for idx, point in enumerate(audio):
        if abs(point) > noise_threshold:
            start = idx
            break

    # Reverse the array for trimming the end
    for idx, point in enumerate(audio[::-1]):
        if abs(point) > noise_threshold:
            end = len(audio) - idx
            break

    return audio[start:end]

"""**DATASET PROCESSING**

Αποθήκευση επεξεργασμένων αρχείων ήχου σε πίνακες για εξαγωγή χαρακτηριστικών και εκπαίδευση μοντέλου.
"""

labels = os.listdir(train_path)
dirs = [f for f in os.listdir(train_path) if isdir(join(train_path, f))]
print('Number of labels: ' + str(len(dirs[:])))
print(dirs)


i=0
durations=[]
sum=0
all_processed_samples=[]
all_labels = []
n_of_recordings=[]
all_recordings= []
duration_of_recordings=[]
sr = 8000





for label in labels:
    waves = [f for f in os.listdir(train_path +'/' + label) if f.endswith('.wav')]
    print("Processing folder: "+ label)
    for wave in waves:
      sample , sr = librosa.load(str(train_path + '/' + label + '/' + wave),sr, mono=True) 
      #apply bandpass filter 
      processed_sample = bandpassFilter(sample, sr)
      #processed_sample, index = librosa.effects.trim(originalSample)
      duration = librosa.get_duration(processed_sample)
      sum = sum + duration
      #processed audio files
      all_processed_samples.append(processed_sample)
      i = i+1
      #labels
      all_labels.append(label)
      #raw audios
      all_recordings.append(sample)
      duration_of_recordings.append(float(len(sample)/sr))

n_of_recordings.append(len(waves))
m_duration=sum/i



    

#plot 
plt.figure(figsize=(30,5))
index = np.arange(len(labels))
plt.bar(index, n_of_recordings)
plt.xlabel('Digits', fontsize=12)
plt.ylabel('No of recordings', fontsize=12)
plt.xticks(index, labels, fontsize=15)
plt.title('No. of recordings for each digit')
plt.show()

plt.hist(np.array(duration_of_recordings))

# print(all_processed_samples)

"""##ΕΞΑΓΩΓΉ ΧΑΡΑΚΤΗΡΙΣΤΙΚΏΝ

Για την εξαγωγή FFT και MFCCs χαρακτηριστικών εφαρμόστηκε stretching ώστε οι τιμές που επιστρέφει ο αλγόριθμος να είναι κοντά μεταξύ τους.Ως αποτέλεσμα η χρονική διάρκεια του σήματος είναι ίδια για όλα τα δεδομενα ώστε το νευρωνικό δίκτυο να αναγνωρίσει με μεγαλύτερη ευκολία τα πρότυπα.

Αν δεν εφαρμοστεί stretching, τα πρότυπα στον άξονα Χ έχουν μεγαλύτερο μήκος ανάλογα με την ταχύτητα που εκφωνούνται απο τον κάθε ομιλητή. Με αυτή τη μέθοδο τα δεδομένα κανονικοποιούνται χωρίς να χάνεται χρήσιμη πληροφορία για την ταξινόμηση τους.

Υπολογίζεται η μέση τιμή των αρχείων ήχου και προσαρμόζονται όλα τα αρχεία στη διάρκεια αυτή.

**ΕΞΑΓΩΓΉ FFT χαρακτηριστικών**
"""

fft_features = []
fft_sum_duration = 0
k = 0
fftFeaturesSize = 0
print ("Extracting Features from " +str(len(all_processed_samples)) +" files, mean duration="+str(m_duration))

for audio in all_processed_samples:
      
    duration = librosa.get_duration(audio)
    fft_sum_duration += duration
    
    ratio = duration / m_duration
    if ratio < 0.1:
        ratio = 0.1


    audio = librosa.effects.time_stretch(audio, ratio)

    frequency, magnitude, samples = FFT(sr, audio, str(k))

    length = 3000
    
    if len(magnitude) < length:
      zero_pad = np.lib.pad(magnitude, (0, length - len(magnitude)), 'constant',
                                     constant_values=0)
      fft_features.append(zero_pad)
    else:
      fft_features.append(magnitute[:length])


    k = k+1

print("Dataset has been converted from time space to frequency space")
print(str(k)," FT features extracted")

"""**ΕΞΑΓΩΓΗ MFCCs χαρακτηριστικών**"""

mfcc_features = []
sum_duration = 0
j=0
equal = 0
larger = 0
smaller = 0

print ("Extracting Features from " +str(len(all_processed_samples)) +" files, mean duration="+str(m_duration))
for audio in all_processed_samples:
      

      
       duration = librosa.get_duration(audio)
       sum_duration = sum_duration + duration

       ratio = duration / m_duration

       if ratio < 0.05:
          ratio = 0.05

       audio = librosa.effects.time_stretch(audio,ratio)

       mfccs = librosa.feature.mfcc(y=audio, sr=sr, n_mfcc=13, hop_length=178)
       flat_mfccs = mfccs.flatten()

       featuresSize = 13 * mfccs.shape[0]

       if len(flat_mfccs) < featuresSize:
         zero_pad = np.pad(flat_mfccs, (0, (featuresSize - len(flat_mfccs))),'constant', constant_values=0)
         mfcc_features.append(zero_pad)
         smaller = smaller + 1

       elif len(flat_mfccs) > featuresSize:
         mfcc_features.append(flat_mfccs[:featuresSize])
         larger = larger +1
       else:
         equal = equal +1
         mfcc_features.append(flat_mfccs)

  
       j = j+1

    
m_duration = sum_duration/i    
print("Extracting MFFCs Features from "+str(j)+" files, trimmed duration="+str(m_duration))
print("MFCCs Features have been extracted")

mfcc_features = np.array(mfcc_features)
all_labels = np.array(all_labels)
fft_features = np.array(fft_features)

print('Size of X:\n', mfcc_features.shape)     
print('Size of Y:\n', all_labels.shape)
print(mfcc_features.dtype)
print(all_labels.dtype)
print(fft_features.shape)

"""## TRAINING THE MODEL

**ΑΡΧΙΤΕΚΤΟΝΙΚΗ ΜΟΝΤΕΛΟΥ**

Θα κατασκευάσουμε SpeechToText model χρησιμοποιώντας ένα convolutioan neural network(CNN). 

 
*  **Conv1d :** To conv1d είναι ενα συνελικτικό νευρωνικό δίκτου που εκτελεί τη συνέλιξη σε μία μόνο διάσταση.
*  **MaxPooling1D :** Το MaxPooling1D παίρνει το μέγιστο πέρα ​​από τα βήματα, αλλά περιορίζεται σε ένα pool_size για κάθε βήμα
*   **Dropout :** To dropout ειναι μια τεχνική όπου αγνοούνται τυχαία νευρώνες κατά την διάρκειας της εκπαιδευσης. Αυτο σημαίνει οτι η συμβολή τους στη ενεργοποίηση των κάτω νευρώνων αφαιρείται στην forward φαση και οποιαδήποτε ενημέρωση βάρους δεν εφαρμόζεται στην πίσω όψη του νευρώνα
*   **Flatten() :** Flatten είναι η συνάρτηση που μετατρέπει τον συγκεντρωτικό map χαρακτηριστικών σε μία στήλη που περνά στο πλήρως συνδεδεμένο επίπεδο
*  **Dense layer :** Ένας Dense layer τροφοδοτεί όλες τις εξόδους από το προηγούμενο στρώμα σε όλους τους νευρώνες, όπου κάθε νευρώνας παρέχει μια έξοδο στο επόμενο στρώμα. Είναι το πιο βασικό επίπεδο στα νευρικά δίκτυα.
Έχουμε 10 κλάσεις άρα 2 layers είναι αρκετοί.
*   **softmax_activation :** Χρησιμοποιείται σε νευρωνικά δίκτυα όταν θέλουμε να δημιουργήσουμε έναν ταξινομητή πολλαπλών τάξεων, ο οποίος λύνει το πρόβλημα της εκχώρησης μιας παρουσίας σε μια τάξη όταν ο αριθμός των πιθανών τάξεων είναι μεγαλύτερος από δύο



---


![modelarchitecture.JPG](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4RDcRXhpZgAATU0AKgAAAAgABAE7AAIAAAAGAAAISodpAAQAAAABAAAIUJydAAEAAAAMAAAQyOocAAcAAAgMAAAAPgAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5pa29zAAAFkAMAAgAAABQAABCekAQAAgAAABQAABCykpEAAgAAAAMxMAAAkpIAAgAAAAMxMAAA6hwABwAACAwAAAiSAAAAABzqAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAyMDowOToxOSAyMzozMTozNgAyMDIwOjA5OjE5IDIzOjMxOjM2AAAATgBpAGsAbwBzAAAA/+ELGGh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4NCjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iPjxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9InV1aWQ6ZmFmNWJkZDUtYmEzZC0xMWRhLWFkMzEtZDMzZDc1MTgyZjFiIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iLz48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyI+PHhtcDpDcmVhdGVEYXRlPjIwMjAtMDktMTlUMjM6MzE6MzYuMTAwPC94bXA6Q3JlYXRlRGF0ZT48L3JkZjpEZXNjcmlwdGlvbj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+PGRjOmNyZWF0b3I+PHJkZjpTZXEgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOmxpPk5pa29zPC9yZGY6bGk+PC9yZGY6U2VxPg0KCQkJPC9kYzpjcmVhdG9yPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0ndyc/Pv/bAEMABwUFBgUEBwYFBggHBwgK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)

**LABEL ENCODER**

  Αναφέρεται στην μετατροπή των ετικετών σε αριθμητική μορφή έτσι ώστε να είναι αναγνωρίσιμη απο την μηχανή. Είναι ενα σημαντικό βήμα προεπεξεργασίας για το σύνολο δεδομένων στην εποπτευόμενη μάθηση.


**TRAIN TEST SPLITS**
*   **x_train :** Περιλαμβάνει όλες τις ανεξάρτητες μεταβλήτες που θα χρησιμοποιηθούν για την εκπαίδευση του μοντέλου. Εχουμε καθορίσει το test_size = 0.2, άρα το 80% των παρατηρήσεων απο τα πλήρη δεδομένα θα χρησιμοποιηθούν για την εκπαίδευση / προσαρμογή του μοντέλου και το υπόλοιπο 20% θα χρησιμοποιηθεί για την δοκιμή του μοντέλου.

*   **X_test :** Το υπόλοιπο 20% που θα χρησιμοποιηθούν για να κάνουν προβλέψεις για την δοκιμή της ακρίβειας του μοντέλου

*   **y_train :** Η μεταβλητή που πρέπει να γίνει η πρόβλεψη της απο το μοντέλο, η οποία περιλαμβάνει ετικέτες κατηγορίας έναντι των ανεξάρτητων μεταβλητών. Θα καθορίσουμε την εξαρτημένη μεταβλητή μας κατα την εκπαίδευση του μοντέλου.
*  **y_test :** Αυτά τα δεδομένα έχουν ετικέτες κατηγορίας για τα δεδομένα δοκιμής οι οποίες θα χρησιμοποιηθούν για τον έλεγχο ακρίβειας μεταξύ πραγματικών και προβλεπόμενων κατηγοριών.





**EarlyStopping and ModelCheckpoint:**

Ειναι callbacks για να σταματήσει η εκπαίδευση την κατάλληλη στιγμή και να σώσει το καλύτερο μοντέλο μετα απο κάθε εποχή.

**BackPropagation**

**optimizers :** Eίναι αλγόριθμοι ή μέθοδοι που χρησιμοποιούνται για την αλλαγή των χαρακτηριστικών του νευρωνικού δικτύου, όπως βάρη και ρυθμός εκμάθησης, προκειμένου να μειωθούν οι απώλειες. Τα εργαλεία βελτιστοποίησης συμβάλλουν στην ταχύτερη λήψη αποτελεσμάτων.

Χρησιμοποιήσα adam optimizer ο οποίος είναι μια επέκταση SGD optimizer o οποίος συνδυάζει τις καλύτερες ιδιότητες των αλγορίθμων AdaGrad και RMSProp για να παρέχει έναν αλγόριθμο βελτιστοποίησης που μπορεί να χειριστεί αραιές κλίσεις σε θορυβώδη προβλήματα.

**CONV MODEL FOR MFCC_FEATURES**
"""

def train_model(mfcc_features, all_labels, labels,model_name, pickle_path):
  mfcc_features = np.array(mfcc_features)

  #convert the output to integer encoded 
  le=LabelEncoder()
  y = le.fit_transform(all_labels)
  classes = list(le.classes_)
  np.save(dir_path + '/classes_conv.npy',le.classes_)
  #and then to one-hot encoded
  y= np_utils.to_categorical(y, num_classes=len(labels))
  #reshape to 3d array for cnn 
  mfcc_features = np.array(mfcc_features).reshape(-1, len(mfcc_features[0]), 1)
  x_train, x_test, y_train, y_test = train_test_split(np.array(mfcc_features), np.array(y), stratify=y, test_size=0.2, random_state=777, shuffle= True)

  tf.convert_to_tensor(y)


  print('x_train: ', x_train.shape, '\nx_test: ', x_test.shape, '\ny_train: ', y_train.shape, '\ny_test: ', y_test.shape)

  K.clear_session()


  inputs = Input(shape=(len(mfcc_features[0]),1))

  conv = Conv1D(8, 13, padding='valid', activation='relu', strides=1)(inputs)
  conv = MaxPooling1D(3)(conv)
  conv = Dropout(0.3)(conv)

  # Second Conv1D layer
  conv = Conv1D(16, 11, padding='valid', activation='relu', strides=1)(conv)
  conv = MaxPooling1D(3)(conv)
  conv = Dropout(0.3)(conv)

  # Third Conv1D layer
  conv = Conv1D(32, 9, padding='valid', activation='relu', strides=1)(conv)
  conv = MaxPooling1D(3)(conv)
  conv = Dropout(0.3)(conv)

  # Fourth Conv1D layer
  conv = Conv1D(64, 2, padding='valid', activation='relu', strides=1)(conv)
  conv = MaxPooling1D(1)(conv)
  conv = Dropout(0.3)(conv)

  # Flatten layer
  conv = Flatten()(conv)

  # Dense Layer 1
  conv = Dense(256, activation='relu')(conv)
  conv = Dropout(0.3)(conv)

  # Dense Layer 2
  conv = Dense(128, activation='relu')(conv)
  conv = Dropout(0.3)(conv)

  outputs = Dense(len(labels), activation='softmax')(conv)

  model = Model(inputs, outputs)
  model.summary()

  model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
  earlystopping = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=10, min_delta=0.0001)

  if not os.path.exists(dir_path + '/saves'):
        os.makedirs(dir_path + '/saves')

  filepath = (dir_path + '/saves/' + model_name)

  checkpoint = ModelCheckpoint(filepath, monitor='val_acc', verbose=1, save_best_only=True, mode='max')
  model.save(filepath, True, True)

  hist = model.fit(x_train, y_train, epochs=100, callbacks=[earlystopping,checkpoint], batch_size=32, validation_data=(x_test, y_test))

  with open(dir_path + '/saves/'+ pickle_path, 'wb') as f:
        pickle.dump(hist.history, f)

  plt.plot(hist.history['loss'],label='train')
  plt.plot(hist.history['val_loss'],label='validation')
  plt.legend()
  plt.show()


  #Scores
  train_score = model.evaluate(x_train, y_train, verbose=0)
  validation_score = model.evaluate(x_test, y_test, verbose=0)

  print('Train Score: ', train_score)
  print('Validation Score: ', validation_score)

train_model(mfcc_features,
            all_labels,
            labels,
            model_name ='mfcc_cnn_model.hdf5',
            pickle_path='mfcc_cnn_model.pickle')

"""**CONV MODEL FOR FT features**"""

def train_model(fft_features, all_labels, labels,model_name, pickle_path):
  fft_features = np.array(fft_features)

  #convert the output to integer encoded 
  le=LabelEncoder()
  y = le.fit_transform(all_labels)
  classes = list(le.classes_)
  np.save(dir_path + '/classes_conv.npy',le.classes_)
  #and then to one-hot encoded
  y= np_utils.to_categorical(y, num_classes=len(labels))
  #reshape to 3d array for cnn 
  fft_features = np.array(fft_features).reshape(-1, len(fft_features[0]), 1)
  x_train, x_test, y_train, y_test = train_test_split(np.array(fft_features), np.array(y), stratify=y, test_size=0.2, random_state=777, shuffle= True)

  tf.convert_to_tensor(y)


  print('x_train: ', x_train.shape, '\nx_test: ', x_test.shape, '\ny_train: ', y_train.shape, '\ny_test: ', y_test.shape)

  K.clear_session()


  inputs = Input(shape=(len(fft_features[0]),1))

  conv = Conv1D(8, 13, padding='valid', activation='relu', strides=1)(inputs)
  conv = MaxPooling1D(3)(conv)
  conv = Dropout(0.3)(conv)

  # Second Conv1D layer
  conv = Conv1D(16, 11, padding='valid', activation='relu', strides=1)(conv)
  conv = MaxPooling1D(3)(conv)
  conv = Dropout(0.3)(conv)

  # Third Conv1D layer
  conv = Conv1D(32, 9, padding='valid', activation='relu', strides=1)(conv)
  conv = MaxPooling1D(3)(conv)
  conv = Dropout(0.3)(conv)

  # Fourth Conv1D layer
  conv = Conv1D(64, 2, padding='valid', activation='relu', strides=1)(conv)
  conv = MaxPooling1D(3)(conv)
  conv = Dropout(0.3)(conv)

  # Flatten layer
  conv = Flatten()(conv)

  # Dense Layer 1
  conv = Dense(256, activation='relu')(conv)
  conv = Dropout(0.3)(conv)

  # Dense Layer 2
  conv = Dense(128, activation='relu')(conv)
  conv = Dropout(0.3)(conv)

  outputs = Dense(len(labels), activation='softmax')(conv)

  model = Model(inputs, outputs)
  model.summary()

  model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
  earlystopping = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=10, min_delta=0.0001)

  if not os.path.exists(dir_path + '/saves'):
        os.makedirs(dir_path + '/saves')

  filepath = (dir_path + '/saves/' + model_name)

  checkpoint = ModelCheckpoint(filepath, monitor='val_acc', verbose=1, save_best_only=True, mode='max')
  model.save(filepath, True, True)

  hist = model.fit(x_train, y_train, epochs=100, callbacks=[earlystopping,checkpoint], batch_size=32, validation_data=(x_test, y_test))

  with open(dir_path + '/saves/'+ pickle_path, 'wb') as f:
        pickle.dump(hist.history, f)

  plt.plot(hist.history['loss'],label='train')
  plt.plot(hist.history['val_loss'],label='validation')
  plt.legend()
  plt.show()


  #Scores
  train_score = model.evaluate(x_train, y_train, verbose=0)
  validation_score = model.evaluate(x_test, y_test, verbose=0)
 

  print('Train Score: ', train_score)
  print('Validation Score: ', validation_score)

train_model(fft_features,
            all_labels,
            labels,
            model_name ='fft_cnn_model.hdf5',
            pickle_path='fft_cnn_model.pickle')

"""## PREDICTIONS"""

def predict(model_filepath,audiofiles, predict_files):
    model = load_model(model_filepath)
    classes = np.load(dir_path + '/classes_conv.npy')

    #print(classes)
    i=0
    for audio in audiofiles:
      prob = model.predict(audio.reshape(1,len(audio),1))
      index = np.argmax(prob[0])
      print("Word #"+str(i+1) +" : " +classes[index])
      i += 1

best_mfcc = dir_path + '/saves/mfcc_cnn_model.hdf5'
best_fft= dir_path + '/saves/fft_cnn_model.hdf5'

"""**PREDICTIONS FOR OUR MFFC MODEL**"""

predict(best_mfcc, mfcc_features, all_processed_samples)

"""**PREDICTIONS FOR OUR FFT MODEL**"""

predict(best_fft, fft_features, all_processed_samples)

# rec_filename = '/content/drive/My Drive/myASR/recordingsdataset/my_recordings/test_recording.wav'
# test_dir = dir_path + '/recordingsdataset/test_recordings'

# !cp '/content/drive/My Drive/myASR/recordingsdataset/split_to_words.py' .
# import split_to_words
# split_to_words.split_to_words(rec_filename,test_dir)

#predict_sample , sr = librosa.load(str(testdir + '/chunk0.wav'),sr = 8000, mono=True)
processed_predict_samples = []
test_dir = dir_path + '/recordingsdataset/test_recordings'

print(len(predict_samples))

my_recordings = [f for f in os.listdir(testdir) if f.endswith('.wav')]
print("Processing folder: ")
for audio in my_recordings:
    predict_sample , sr = librosa.load(str(testdir + '/' +audio),sr, mono=True) 
    processed_predict_sample = bandpassFilter(predict_sample, sr)
    trim_silence(processed_predict_sample)
    duration = librosa.get_duration(processed_predict_sample)
    processed_predict_samples.append(processed_predict_sample)
    #processed audio files
      


predict_features=[]

for audio in processed_predict_samples:
      
    duration = librosa.get_duration(audio)
    fft_sum_duration += duration
    
    ratio = duration / m_duration
    if ratio < 0.1:
        ratio = 0.1


    audio = librosa.effects.time_stretch(audio, ratio)

    frequency, magnitude, samples = FFT(sr, audio, str(k))

    length = 3000
    
    if len(magnitude) < length:
      zero_pad = np.lib.pad(magnitude, (0, length - len(magnitude)), 'constant',
                                     constant_values=0)
      predict_features.append(zero_pad)
    else:
      predict_features.append(magnitute[:length])


print("Dataset has been converted from time space to frequency space")

predict(best_fft, predict_features, processed_predict_samples)

"""#ΣΥΜΠΕΡΑΣΜΑΤΑ

Τα αποτελεσμάτα δεν ήταν αρκετά ικανοποιητικά καθώς πετύχαμε ποσοστό ακριβείας train 56% και 54% στο test. 


Χρησιμοποίησα στην αρχή ένα σύνολο δεδομένων 2500 δειγμάτων και έπειτα ένα σύνολο 3000 δεδομένων. 
Παρατήρησα ότι ακομά και αυτή η μικρή αύξηση στο σύνολο δεδομένων αυξήσε το πόσοστο ακρίβειας απο 50% σε 60% στο train και απο 48% σε 57% στο test

Αν είχα χρησιμοποιήσει ενα μεγαλύτερο σύνολο δεδομένων τα ποσοστά ακριβείας στο μοντελο θα ήταν ακόμα πιο υψηλά και έτσι το συνελικτικό νευρωνικό δίκτυο θα πετύχαινε καλύτερες προβλέψεις.

Η πρόβλεψη ήταν λάθος και σίγουρα δεν ήταν αυτη που περιμέναμε ή μαλλον ήταν λόγω του ποσοστού ακρίβειας.

Μια βασική διαφορά των CNN απο τα κλασσικά feed forward νευρωνικά δίκτυα  είναι οτι μπορούν να λειτουργήσουν εξίσου καλά και σε μη επεξεργασμένα χαρακτηριστικά κατι που είναι πολυ σημαντικό για την πρόβλεψη.
"""